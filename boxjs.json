/*
Bingç§¯åˆ†å®Œæ•´ç‰ˆ - ä¸‰åˆä¸€ç‰ˆæœ¬
æ•´åˆæœç´¢Cookieè·å–ã€ç§¯åˆ†é¢æ¿Cookieè·å–ã€ç§¯åˆ†ä»»åŠ¡æ‰§è¡Œ
ä½œè€…: @ader90520
*/

// åˆ¤æ–­æ‰§è¡Œæ¨¡å¼
if (typeof $request !== 'undefined') {
    // é‡å†™æ¨¡å¼ï¼šè·å–Cookie
    handleCookieRequest();
} else {
    // è„šæœ¬æ¨¡å¼ï¼šæ‰§è¡Œç§¯åˆ†ä»»åŠ¡
    executeBingTasks();
}

function handleCookieRequest() {
    const $ = initToolkit();
    
    if ($request.url.includes('rewards.bing.com')) {
        // ç§¯åˆ†é¢æ¿Cookieè·å–
        const ck = $request.headers["Cookie"];
        $.msg("Bingç§¯åˆ†", "ğŸ‰é¢æ¿Cookieè·å–æˆåŠŸï¼Œè¯·ç¦ç”¨é‡å†™è§„åˆ™");
        $.log("ğŸ‰é¢æ¿Cookieè·å–æˆåŠŸ");
        $.setdata("bingPointCookieKey", ck);
        $.done();
    } else if ($request.url.includes('cn.bing.com/search')) {
        // æœç´¢Cookieè·å–
        const ck = $request.headers["Cookie"];
        if ($request.url.includes('q=pc')) {
            $.msg("Bingæœç´¢", "ğŸ‰PCç«¯Cookieè·å–æˆåŠŸ");
            $.setdata("bingSearchCookiePCKey", ck);
        } else if ($request.url.includes('q=testt')) {
            $.msg("Bingæœç´¢", "ğŸ‰ç§»åŠ¨ç«¯Cookieè·å–æˆåŠŸ");
            $.setdata("bingSearchCookieMobileKey", ck);
        }
        $.done();
    }
}

async function executeBingTasks() {
    const $ = new Toolkit("Bingç§¯åˆ†å®Œæ•´ç‰ˆ");
    
    // è¯»å–é…ç½®
    const config = {
        resetHours: $.getVal('bingResetHours') || 8,
        pointCookie: $.getVal('bingPointCookieKey'),
        pcCookie: $.getVal('bingSearchCookiePCKey'),
        mobileCookie: $.getVal('bingSearchCookieMobileKey'),
        pcSearchCount: $.getVal('bingPcSearchCount') || 30,
        mobileSearchCount: $.getVal('bingMobileSearchCount') || 20,
        edgeSearchCount: $.getVal('bingEdgeSearchCount') || 10,
        useCnDomain: $.getVal('bingUseCnDomain') !== "false",
        searchInterval: $.getVal('bingSearchInterval') || 5,
        enableDebug: $.getVal('bingEnableDebug') === "true"
    };

    // çŠ¶æ€è®°å½•
    const STATE = {
        LAST_EXEC_DATE: 'bingLastExecDate',
        PC_SEARCH_TODAY: 'bingPcSearchToday',
        MOBILE_SEARCH_TODAY: 'bingMobileSearchToday', 
        EDGE_SEARCH_TODAY: 'bingEdgeSearchToday',
        CACHE_POINTS: 'bingCachePoints'
    };

    const todayString = $.formatDate(new Date(), 'yyyyMMdd');
    let searchState = {
        pc: { count: $.getVal(STATE.PC_SEARCH_TODAY) || 0, total: config.pcSearchCount },
        mobile: { count: $.getVal(STATE.MOBILE_SEARCH_TODAY) || 0, total: config.mobileSearchCount },
        edge: { count: $.getVal(STATE.EDGE_SEARCH_TODAY) || 0, total: config.edgeSearchCount }
    };

    // æ£€æŸ¥é‡ç½®æ¡ä»¶
    if (!checkResetCondition(config.resetHours, todayString, $, STATE)) {
        $.log("â° ä»Šæ—¥ä»»åŠ¡å·²å®Œæˆï¼Œè·³è¿‡æ‰§è¡Œ");
        await showCurrentPoints(config.pointCookie, $);
        return;
    }
    
    $.log("ğŸ¯ å¼€å§‹æ‰§è¡ŒBingç§¯åˆ†ä»»åŠ¡");
    
    let totalPoints = 0;
    let taskResults = { points: 0, pc: 0, mobile: 0, edge: 0 };
    
    // æ‰§è¡Œç§¯åˆ†ä»»åŠ¡
    if (config.pointCookie) {
        $.log("\nğŸ“‹ å¼€å§‹ç§¯åˆ†ä»»åŠ¡...");
        taskResults.points = await executePointTasks(config.pointCookie, $);
        totalPoints += taskResults.points;
    } else {
        $.log("âŒ æœªé…ç½®ç§¯åˆ†é¢æ¿Cookieï¼Œè·³è¿‡ç§¯åˆ†ä»»åŠ¡");
    }
    
    // æ‰§è¡Œæœç´¢ä»»åŠ¡
    if (config.pcCookie) {
        $.log("\nğŸ’» å¼€å§‹PCç«¯æœç´¢...");
        taskResults.pc = await executeSearch('pc', searchState.pc, config, $);
        totalPoints += taskResults.pc;
    } else {
        $.log("âŒ æœªé…ç½®PCç«¯Cookieï¼Œè·³è¿‡PCæœç´¢");
    }
    
    if (config.mobileCookie) {
        $.log("\nğŸ“± å¼€å§‹ç§»åŠ¨ç«¯æœç´¢...");
        taskResults.mobile = await executeSearch('mobile', searchState.mobile, config, $);
        totalPoints += taskResults.mobile;
    } else {
        $.log("âŒ æœªé…ç½®ç§»åŠ¨ç«¯Cookieï¼Œè·³è¿‡ç§»åŠ¨æœç´¢");
    }
    
    if (config.pcCookie) {
        $.log("\nğŸ”µ å¼€å§‹Edgeç«¯æœç´¢...");
        taskResults.edge = await executeSearch('edge', searchState.edge, config, $);
        totalPoints += taskResults.edge;
    }
    
    // ä¿å­˜çŠ¶æ€å’Œæ˜¾ç¤ºç»“æœ
    saveExecutionState(todayString, searchState, $, STATE);
    await showFinalResults(taskResults, totalPoints, config.pointCookie, $);
}

function checkResetCondition(resetHours, todayString, $, STATE) {
    const now = new Date();
    const currentHour = now.getHours();
    const lastExecDate = $.getVal(STATE.LAST_EXEC_DATE);
    
    if (currentHour >= resetHours && lastExecDate !== todayString) {
        $.log("ğŸ”„ æ£€æµ‹åˆ°é‡ç½®æ—¶é—´ï¼Œæ¸…é™¤æ˜¨æ—¥çŠ¶æ€");
        resetDailyState($, STATE);
        return true;
    }
    
    if (lastExecDate === todayString) {
        return false;
    }
    
    return true;
}

function resetDailyState($, STATE) {
    $.setVal("0", STATE.PC_SEARCH_TODAY);
    $.setVal("0", STATE.MOBILE_SEARCH_TODAY);
    $.setVal("0", STATE.EDGE_SEARCH_TODAY);
}

function saveExecutionState(todayString, searchState, $, STATE) {
    $.setVal(todayString, STATE.LAST_EXEC_DATE);
    $.setVal(searchState.pc.count.toString(), STATE.PC_SEARCH_TODAY);
    $.setVal(searchState.mobile.count.toString(), STATE.MOBILE_SEARCH_TODAY);
    $.setVal(searchState.edge.count.toString(), STATE.EDGE_SEARCH_TODAY);
}

async function executePointTasks(pointCookie, $) {
    let earnedPoints = 0;
    
    try {
        const dashboard = await getDashboard(pointCookie, $);
        if (!dashboard?.dashboard) {
            $.log("âŒ æ— æ³•è·å–ç§¯åˆ†é¢æ¿");
            return 0;
        }
        
        const tasks = getAvailableTasks(dashboard);
        $.log(`ğŸ“‹ å‘ç° ${tasks.length} ä¸ªå¯ç”¨ä»»åŠ¡`);
        
        for (const task of tasks) {
            const result = await processTask(task, dashboard.rvt, pointCookie, $);
            if (result.success) {
                earnedPoints += result.points;
                $.log(`âœ… å®Œæˆä»»åŠ¡: ${task.title} +${result.points}åˆ†`);
            }
            await $.sleep(2000 + Math.random() * 2000);
        }
    } catch (e) {
        $.log("âŒ ç§¯åˆ†ä»»åŠ¡æ‰§è¡Œå¤±è´¥:", e);
    }
    
    return earnedPoints;
}

function getAvailableTasks(dashboard) {
    const tasks = [];
    const promotions = [...(dashboard.dashboard.morePromotions || [])];
    
    if (dashboard.dashboard.promotionalItem) {
        promotions.push(dashboard.dashboard.promotionalItem);
    }
    
    for (const task of promotions) {
        if (task.complete === false && task.pointProgressMax > 0) {
            tasks.push({
                title: task.attributes?.title || "æœªçŸ¥ä»»åŠ¡",
                points: task.pointProgressMax,
                type: task.attributes?.type,
                name: task.name,
                hash: task.hash
            });
        }
    }
    
    return tasks;
}

async function processTask(task, rvt, pointCookie, $) {
    if (task.type === "urlreward") {
        const success = await reportActivity(task, rvt, pointCookie, $);
        return {
            success: success,
            points: success ? task.points : 0
        };
    }
    
    $.log(`â­ï¸ è·³è¿‡ä»»åŠ¡ç±»å‹: ${task.type}`);
    return { success: false, points: 0 };
}

async function executeSearch(deviceType, state, config, $) {
    if (state.count >= state.total) {
        $.log(`âœ… ${getDeviceName(deviceType)}æœç´¢å·²å®Œæˆ`);
        return 0;
    }
    
    const remaining = state.total - state.count;
    $.log(`ğŸ” å¼€å§‹${getDeviceName(deviceType)}æœç´¢ï¼Œå‰©ä½™${remaining}æ¬¡`);
    
    let successCount = 0;
    
    for (let i = 0; i < remaining; i++) {
        const success = await performSingleSearch(deviceType, state.count + i + 1, config, $);
        if (success) {
            successCount++;
            state.count++;
        }
        
        if (i < remaining - 1) {
            await $.sleep(config.searchInterval * 1000);
        }
    }
    
    const pointsEarned = Math.floor(successCount / 3) * 8;
    $.log(`ğŸ‰ ${getDeviceName(deviceType)}æœç´¢å®Œæˆ: æˆåŠŸ${successCount}æ¬¡ï¼Œè·å¾—çº¦${pointsEarned}åˆ†`);
    
    return pointsEarned;
}

function getDeviceName(deviceType) {
    const names = { 'pc': 'PCç«¯', 'mobile': 'ç§»åŠ¨ç«¯', 'edge': 'Edgeç«¯' };
    return names[deviceType] || deviceType;
}

async function performSingleSearch(deviceType, round, config, $) {
    const baseUrl = config.useCnDomain ? "https://cn.bing.com" : "https://www.bing.com";
    const randomWord = generateSearchKeyword();
    const searchUrl = `${baseUrl}/search?q=${encodeURIComponent(randomWord)}&form=QBLH&qs=n`;
    
    const headers = getSearchHeaders(deviceType, config);
    
    try {
        const response = await $.http.get({
            url: searchUrl,
            headers: headers,
            timeout: 10000
        });
        
        if (response.status === 200) {
            if (config.enableDebug) {
                $.log(`âœ… ${getDeviceName(deviceType)}ç¬¬${round}æ¬¡æœç´¢æˆåŠŸ`);
            }
            return true;
        } else {
            $.log(`âŒ ${getDeviceName(deviceType)}æœç´¢å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}`);
            return false;
        }
    } catch (error) {
        $.log(`ğŸ’¥ ${getDeviceName(deviceType)}æœç´¢å¼‚å¸¸: ${error.message}`);
        return false;
    }
}

function getSearchHeaders(deviceType, config) {
    const baseHeaders = {
        "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "accept-language": "zh-CN,zh;q=0.9,en;q=0.8",
        "cache-control": "no-cache",
        "pragma": "no-cache"
    };
    
    const deviceConfigs = {
        'pc': {
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "cookie": config.pcCookie
        },
        'mobile': {
            "user-agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.3 Mobile/15E148 Safari/604.1",
            "cookie": config.mobileCookie
        },
        'edge': {
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0",
            "cookie": config.pcCookie
        }
    };
    
    return { ...baseHeaders, ...deviceConfigs[deviceType] };
}

function generateSearchKeyword() {
    const prefixes = ['ä»€ä¹ˆæ˜¯', 'å¦‚ä½•', 'ä¸ºä»€ä¹ˆ', 'æœ€å¥½çš„', 'æœ€æ–°çš„', 'å­¦ä¹ ', 'äº†è§£'];
    const topics = ['äººå·¥æ™ºèƒ½', 'æœºå™¨å­¦ä¹ ', 'ç¼–ç¨‹', 'ç§‘æŠ€', 'å¥åº·', 'æ—…æ¸¸', 'ç¾é£Ÿ', 'éŸ³ä¹'];
    const suffixes = ['çš„æ–¹æ³•', 'çš„æŠ€å·§', 'çš„åŸç†', 'çš„å‘å±•', 'çš„åº”ç”¨'];
    
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const topic = topics[Math.floor(Math.random() * topics.length)];
    const suffix = Math.random() > 0.5 ? suffixes[Math.floor(Math.random() * suffixes.length)] : '';
    const randomNum = Math.floor(Math.random() * 1000);
    
    return `${prefix}${topic}${suffix} ${randomNum}`;
}

async function getDashboard(pointCookie, $) {
    if (!pointCookie) return null;
    
    const headers = {
        "authority": 'rewards.bing.com',
        "accept": 'application/json, text/javascript, */*; q=0.01',
        "cookie": pointCookie,
        "user-agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
    };
    
    try {
        const response = await $.http.get({
            url: `https://rewards.bing.com/?_=${Date.now()}`,
            headers: headers
        });
        
        if (response.status === 200) {
            const data = response.body;
            const rvtMatch = data.match(/__RequestVerificationToken.*?value="([^"]*)"/);
            const dashboardMatch = data.match(/var dashboard = ({[^;]*});/);
            
            if (rvtMatch && dashboardMatch) {
                return {
                    dashboard: JSON.parse(dashboardMatch[1]),
                    rvt: rvtMatch[1]
                };
            }
        }
    } catch (e) {
        $.log("âŒ è·å–ç§¯åˆ†é¢æ¿å¤±è´¥");
    }
    
    return null;
}

async function reportActivity(task, rvt, pointCookie, $) {
    const headers = {
        "authority": 'rewards.bing.com',
        "content-type": 'application/x-www-form-urlencoded',
        "cookie": pointCookie,
        "x-requested-with": 'XMLHttpRequest'
    };
    
    const body = `id=${task.name}&hash=${task.hash}&timeZone=480&activityAmount=1&__RequestVerificationToken=${rvt}`;
    
    try {
        const response = await $.http.post({
            url: `https://rewards.bing.com/api/reportactivity?_=${Date.now()}`,
            headers: headers,
            body: body
        });
        
        return response.status === 200;
    } catch (e) {
        return false;
    }
}

async function showCurrentPoints(pointCookie, $) {
    const dashboard = await getDashboard(pointCookie, $);
    if (dashboard?.dashboard) {
        const points = dashboard.dashboard.userStatus?.availablePoints || "æœªçŸ¥";
        $.msg(
            "Bingç§¯åˆ†çŠ¶æ€",
            `å½“å‰ç§¯åˆ†: ${points}`,
            "ä»Šæ—¥ä»»åŠ¡å·²å®Œæˆ"
        );
    }
}

async function showFinalResults(results, totalPoints, pointCookie, $) {
    const dashboard = await getDashboard(pointCookie, $);
    const currentPoints = dashboard?.dashboard?.userStatus?.availablePoints || "æœªçŸ¥";
    
    $.setVal(currentPoints, 'bingCachePoints');
    
    const message = `
ä»»åŠ¡ç§¯åˆ†: ${results.points}åˆ†
PCæœç´¢: ${results.pc}åˆ†  
ç§»åŠ¨æœç´¢: ${results.mobile}åˆ†
Edgeæœç´¢: ${results.edge}åˆ†
æ€»è®¡è·å¾—: ${totalPoints}åˆ†
å½“å‰ç§¯åˆ†: ${currentPoints}
    `.trim();
    
    $.msg("Bingç§¯åˆ†ä»»åŠ¡å®Œæˆ", message);
}

// å·¥å…·å‡½æ•°
function initToolkit() {
    return {
        msg: (title, subtitle, body) => {
            if (typeof $notification !== 'undefined') {
                $notification.post(title, subtitle, body);
            }
        },
        log: (message) => console.log(message),
        setdata: (key, val) => {
            if (typeof $persistentStore !== 'undefined') {
                return $persistentStore.write(val, key);
            }
            if (typeof $prefs !== 'undefined') {
                return $prefs.setValueForKey(val, key);
            }
        },
        getdata: (key) => {
            if (typeof $persistentStore !== 'undefined') {
                return $persistentStore.read(key);
            }
            if (typeof $prefs !== 'undefined') {
                return $prefs.valueForKey(key);
            }
        },
        done: () => {
            if (typeof $done !== 'undefined') $done();
        }
    };
}

// Toolkitç±»
function Toolkit(name, id, options) {
    return new class {
        constructor(name, id, options) {
            this.name = name;
            this.id = id;
            this.options = options || {};
            this.logs = [];
            this.startTime = Date.now();
            this.log("", `ğŸ”” ${this.name} å¼€å§‹æ‰§è¡Œ`);
        }
        
        log(...args) {
            const message = args.join(" ");
            this.logs.push(message);
            console.log(message);
        }
        
        getVal(key, defaultValue = "") {
            if (typeof $persistentStore !== 'undefined') {
                return $persistentStore.read(key) || defaultValue;
            }
            if (typeof $prefs !== 'undefined') {
                return $prefs.valueForKey(key) || defaultValue;
            }
            return defaultValue;
        }
        
        setVal(value, key) {
            if (typeof $persistentStore !== 'undefined') {
                return $persistentStore.write(value, key);
            }
            if (typeof $prefs !== 'undefined') {
                return $prefs.setValueForKey(value, key);
            }
            return true;
        }
        
        msg(title, subtitle, body) {
            if (typeof $notification !== 'undefined') {
                $notification.post(title, subtitle, body);
            }
            this.log(`ğŸ“¢ ${title}: ${subtitle} - ${body}`);
        }
        
        async sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        formatDate(date, fmt) {
            const o = {
                "M+": date.getMonth() + 1,
                "d+": date.getDate(),
                "H+": date.getHours(),
                "m+": date.getMinutes(), 
                "s+": date.getSeconds(),
                "q+": Math.floor((date.getMonth() + 3) / 3),
                "S": date.getMilliseconds()
            };
            if (/(y+)/.test(fmt)) {
                fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
            }
            for (const k in o) {
                if (new RegExp("(" + k + ")").test(fmt)) {
                    fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));
                }
            }
            return fmt;
        }
        
        // HTTPè¯·æ±‚æ–¹æ³•
        http = {
            get: (options) => {
                return new Promise((resolve) => {
                    if (typeof $httpClient !== 'undefined') {
                        $httpClient.get(options, (error, response, body) => {
                            resolve({ error, status: response?.status, body });
                        });
                    } else if (typeof $task !== 'undefined') {
                        $task.fetch(options).then(response => {
                            resolve({ error: null, status: response.statusCode, body: response.body });
                        }, error => {
                            resolve({ error, status: null, body: null });
                        });
                    } else {
                        resolve({ error: "No HTTP client", status: null, body: null });
                    }
                });
            },
            
            post: (options) => {
                return new Promise((resolve) => {
                    if (typeof $httpClient !== 'undefined') {
                        $httpClient.post(options, (error, response, body) => {
                            resolve({ error, status: response?.status, body });
                        });
                    } else if (typeof $task !== 'undefined') {
                        options.method = 'POST';
                        $task.fetch(options).then(response => {
                            resolve({ error: null, status: response.statusCode, body: response.body });
                        }, error => {
                            resolve({ error, status: null, body: null });
                        });
                    } else {
                        resolve({ error: "No HTTP client", status: null, body: null });
                    }
                });
            }
        };
    }(name, id, options);
}